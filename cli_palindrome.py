# The one line CLI tool. Will do nothing if no command line argument is passed
(lambda k: len(k.argv) > 1 and print('Longest palindrome is:', [str.join(' ',k.argv[1:])[q[0]:q[1]+1]for q in[[[e for w in range(1,len(str.join(' ',k.argv[1:]))+1)for e in[(q[0],q[1])for q in[(i,i+w-1)for i in range(len(str.join(' ',k.argv[1:]))-1) if i+w-1<len(str.join(' ',k.argv[1:]))]if r[q[0]][q[1]] or(r[q[0]+1][q[1]-1]and str.join(' ',k.argv[1:])[q[0]]==str.join(' ',k.argv[1:])[q[1]]and not r[q[0]].__setitem__(q[1],True))or r[q[0]].__setitem__(q[1],False)]]for r in[[[True if i==j or(j==i+1 and str.join(' ',k.argv[1:])[i]==str.join(' ',k.argv[1:])[j])else None for j in range(len(str.join(' ',k.argv[1:])))]for i in range(len(str.join(' ',k.argv[1:])))]]][0][-1]]][0]if len(k.argv) > 1 and len(str.join(' ',k.argv[1:]))>1 else str.join(' ',k.argv[1:])))(__import__('sys'))

# The same algorithm as fxn
def p(s):
	return [s[q[0]:q[1]+1]for q in[[[e for w in range(1,len(s)+1)for e in[(q[0],q[1])for q in[(i,i+w-1)for i in range(len(s)-1) if i+w-1<len(s)]if r[q[0]][q[1]] or(r[q[0]+1][q[1]-1]and s[q[0]]==s[q[1]]and not r[q[0]].__setitem__(q[1],True))or r[q[0]].__setitem__(q[1],False)]]for r in[[[True if i==j or(j==i+1 and s[i]==s[j])else None for j in range(len(s))]for i in range(len(s))]]][0][-1]]][0]if len(s)>1 else s